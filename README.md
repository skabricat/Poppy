
**RU** | [EN](README_EN.md)

# Poppy

Cвободный зонтичный проект, направления которого в совокупности предоставляют целостный пользовательский опыт, схожий с использованием Mac OS X (в частности, версии 10.9 Mavericks), но не включающий его самые худшие стороны, такие как привязка к конкретному оборудованию или плата за программное обеспечение.

#### Концепт

![Концепт](Resources/Concept.png)

#### Скриншот

![Скриншот](Resources/Screenshot.png)

----

Весь проект основан на идее, что **ядра** операционных систем можно разложить по уровням следующим образом:
- **Уровень 0** (хостовое, нулевого уровня, 0K) &mdash; ядро в привычном понимании. Загружается в память с помощью оборудования и загрузчика, общается с ресурсами системы напрямую, реализует объекты (такие как процессы, потоки, таймеры, файловые системы и т.д.) и интерфейс к ним, запускает PID 1.
- **Уровень 1** (гостевое, первого уровня, 1K) &mdash; оверлейное ядро. Как и хостовое, предоставляет системные вызовы, управляет процессами, связью между ними и прочими объектами. 1K может во всём полагаться на 0K или обладать дополнительными ограничениями и расширениями. Может иметь выделенный KPL (дальнозоркая KPL-совместимость) или использовать ABI ядра нулевого уровня напрямую (близорукая KPL-совместимость). В теории, любое 0K подходит в качестве хоста, но на практике - лучше всего с этим справляются UNIX-подобные и микро- или экзоядра.

	Ядра уровня 1 делятся на два класса: централизованные - всё ядро в одном хостовом процессе, а дочерние процессы виртуализируются на базе его thread'ов; и распределённые - основной хостовый процесс ядра fork'ается, его логика сквозным образом контролирует дочерние, а всё общее состояние и связь проходят через синхронизированное и высокопроизводительное хостовое IPC типа POSIX Shared Memory. Выбор _второго_ класса принципиален для жизнеспособности гостевого ядра вне "полевых испытаний", т.к. реально-используемые хостовые ядра (FreeBSD, Linux...) накладывают большие ограничения на возможности ядер первого уровня даже при UNIX-подобной архитектуре, и не годятся для централизованных 1K в desktop-сегменте.

	Классическим примером _централизованного_ гостевого ядра представляется User-mode Linux, первичная цель которого состоит в _удобстве изоляции, тестирования и отладки без перезагрузки физического хоста_; в свою очередь цель _распределённого_ Opium - _независимость архитектуры при переиспользовании некоторого набора сторонних низкоуровневых решений_.
	- Kernel Portability Layer (**KPL**) &mdash; слой совместимости, упрощающий переносимость ядра уровня 1 между хостами, засчёт предварительной минимизации различий в ABI ядер уровня 0. Развитый слой может включать I0K как способ отделиться и значительно удалиться от других ОС. Слой является надстройкой (или расширением) концепции HAL, где к "hardware" добавлено ядро нулевого уровня.
		- Integrated 0K (**I0K**) &mdash; встроенная в KPL реализация хостового ядра. Правильная архитектура гостевого ядра позволяет при желании иметь _минимальное_ хостовое экзоядро (отвечающее только за базовую среду исполнения и безопасное общение с оборудованием) и выносить всю серьёзную логику на свой собственный уровень. Хотя на практике это достаточно плохое и неоправданное решение как для разработчиков, так и для конечного пользователя, ввиду резко возрастающей сложности поддержки аппаратной части и снижения доступного для установки ОС оборудования соответственно.
- **Уровень N** (супер-гостевое, N-ного уровня, NK) &mdash; оверлейное ядро, работающее (или по крайней мере экспериментально запущенное) поверх другого оверлейного ядра. Это может быть ядро, намеренно или случайно реализующее KPL-совместимость с самим собой или с неким сторонним оверлейным ядром. Термин строго контекстуален и относится только к определённой конфигурации.

----

Poppy Kernel (**Opium**) &mdash; распределённое ядро уровня 1, обеспечивающее _беспрекословную_ работоспособность PSC на UNIX-подобных ядрах уровня 0. В обычной конфигурации запускается как [PID 1, UID 0] поверх FreeBSD. Помимо абстракций над нулевым ядром (KPL), обладает собственной логикой (IOKit, VFS, KSP, IPC, KEM и объекты):
- Input/Output Kit (**IOKit**) &mdash; в контексте Opium, подсистема ввод-вывода, предоставляющая унифицированную и независимую от типа хостового ядра (более безопасную, чем сырой KPL), объектно-ориентированную модель взаимодействия с устройствами. Технически, клиентский доступ к оборудованию осуществляется по глобальному IPC гостевого ядра (для реестра и событий) и локальным системным вызовам (для конкретных устройств), но в обоих случаях используется публичный IOKit API и для клиента нет заметной разницы. Подсистема включает в себя всего три уровня семантики (информации и методов взаимодействия):
	1. На основании KPL, непосредственно в ядре: физические устройства хоста (ACPI, PCI, SATA, USB...).
	2. На основании IOKit и KPL, в shim-kext'ах: логические устройства хоста (файловые системы, точки монтирования...); виртуальные устройства хоста (RAM-диск, аудиоканал...).
	3. На основании IOKit, в полноценных kext'ах: логические устройства гостя (только на экзоядрах, которые имеют доступный для KPL аппаратный API); виртуальные устройства гостя.
- Virtual File System (**VFS**) &mdash; абстрактная подсистема, обеспечивающая единообразный доступ клиентских программ и приложений к разным типам файловых систем. В контексте Opium, VFS стандартно работает в два этапа:
	1. Регистрация файловых систем, при загрузке kext'ов. Данные, экспортируемые этими ФС, подобно семантическому набору IOKit, могут быть физическими, логическими или виртуальными. В первых двух случаях используется информация, полученная от IOKit, в третьем это необязательно. Каждый kext реализует свой конкретный набор методов для файловых систем через общий абстрактный набор. В частности, kext может быть тонким shim, проксирующим одну или несколько ФС хоста.
	2. Ответ на запросы, при исполнении процессов. Когда процесс делает системный вызов, VFS ищет в своём реестре зарегистрированную файловую систему с нужным типом (mount) или handle к ней (open, read...) и вызывает методы, реализованные kext'ом. Примером виртуальной ФС является devfs, которая получает информацию об оборудовании от IOKit и маппит вызовы к его методам устройств на обычные файловые операции POSIX.
- Kernel Security Policy (**KSP**) &mdash; декларативная подсистема безопасности, существующая как расширение POSIX-прав (UID, GID, PID), позволяющая тонко настраивать доступ к системным вызовам со стороны процессов, и явно обращающаяся к пользователю с помощью доверенных агентов (CLI и GUI) в спорных случаях. Политика позволяет настраивать доступ как на основе привычных POSIX, так и на основе новых логических ограничений. Обладает кешем решений и белым списком, может быть отключена по желанию администратора. Лучше всего работает, когда настроены пароли, но без них не становится бесполезной и все равно может ограничить даже UID 0. Ближайшие аналоги для сравнения - UAC и SELinux.
- Inter-Process Communication (**IPC**) &mdash; в контексте Opium, совокупность подсистем взаимодействия процессов, где основной является надмножество Mach IPC, а вторичной - стандартное POSIX IPC. В отличии от XNU, POSIX IPC в Opium строится не поверх Mach IPC, а параллельно с ним.
- Kernel Execution Marshall (**KEM**) &mdash; расширяемая подсистема исполнения и координации различных программных сред и форматов (Root, WebAssembly, ELF...), выполняющая инициализацию процессов, динамическое связывание библиотек, а также маршаллинг данных и вызовов функций на уровне ядра. Маршалл стремиться обеспечить такой уровень бесшовной работы множества сред, при котором конечному пользователю не придётся думать о различиях между языками программирования или форматах распространения программ. Отличается от проектов типа JVM или .NET тем, что располагаясь на более низком уровне, поддерживает многозадачность и разные модели памяти в реальном времени.

[Poppy Programming Language (**Root**)](OS/System/Library/Kernels/Opium/Includes/ExecutionMarshall/Root) &mdash; системный интерпретируемый язык программирования общего назначения. Официально поставляется исключительно в рамках Opium KEM, однако потенциально поддерживает сборку переносимого интерпретатора. Значительная часть PSC (в частности, нетребовательного к производительности кода) пишется на Root.

Poppy Software Collection (**PSC**) &mdash; набор библиотек, фреймворков, консольных программ и графических приложений, совместимых с UX и некоторой частью архитектуры Darwin и OS X. Большая часть ПО в коллекции является портом и обратным инжинирингом из GNU, GnuStep, Darwin и OS X. Базовая часть PSC в большей степени зависит от уровня POSIX-совместимости ядра, чем конкретно от Opium-специфичных системных вызовов, поэтому может быть использована на некоторых ядрах уровня 0 без изменений (при совместимости сред исполнения). Та же часть, которую видит пользователь в первую очередь, а именно: `launchd`, `WindowServer`, `LoginWindow`, `Enviro`, `Dock`, `System Preferences` и т.д., могут зависеть от особых механизмов ядра и файловой структуры Poppy OS, следовательно их работа вне Opium не гарантируется и не ожидается.

Poppy Operating System (**Poppy OS**) &mdash; сборка FreeBSD + Poppy Kernel + Poppy Programming Language + Poppy Software Collection. Всё то, к чему стремится проект Poppy, сходится в этой конечной точке. Операционную систему Poppy можно рассматривать как клон Mac OS X, если не вдаваться в подробности, и с пользовательской точки зрения это будет оправданно, однако система проходит совсем другой путь разработки: многие оригинальные решения пересматриваются, прежде чем в том или ином виде попасть в Poppy (например, система никого не ограничивает в возможностях разработки и установки тем).

### Архитектура

	Аппаратное обеспечение
	Ядро (нативной ОС) уровня 0
	Ядро (Poppy OS) уровня 1 (Opium): Общие kext'ы
		KPL: Совместимость с FreeBSD, Linux...
		IOKit: Kext'ы драйверов
		VFS: Kext'ы файловых систем
		Системные вызовы: Mach (IPC) и POSIX API, соблюдающие KSP
		KEM: Среды Root, WebAssembly, ELF
			PSC
				Библиотеки, фреймворки
					CoreFoundation Framework, CoreTypes Framework...
					CoreGraphics Framework...
					Leaf Framework
				Программы, приложения
					launchd: Launch Daemons, Launch Agents
					WindowServer, LoginWindow...
					Enviro, Dock, System Preferences, Activity Monitor...

## Вопросы / Ответы

### Почему дизайн OS X 10.9, а не [что угодно]?

Poppy с самого своего начала ориентируется на последнюю скевоморфичную версию OS X как на околоидеальный UX, где особенно значимыми считаются:
- Глобальная строка меню - удобный и элегантный способ доступа к служебной части приложений, рационально использующий место на экране.
- Finder, Dock, Launchpad и Mission Control - давно зарекомендовавшие себя решения, где каждый элемент на своём месте (ну, почти).
- Единый графический фреймворк - общие стиль и способ разработки/взаимодействия со всеми приложениями.
- Простейший способ организации файловой структуры, позволяющий:
	- Чётко видеть где и что находится, с учётом трёх доменов (пользовательский, локальный и системный), не используя строку поиска.
	- Устанавливать или удалять фреймворки, приложения и плагины одной самодостаточной папкой (иногда нескольких, совсем редко через специализированный установщик).
	- Нормальную работу POSIX-программ, ввиду _скрытой от рядового пользователя_ совместимости с FHS на низком уровне.
- Досконально прорисованные и метрически выверенные элементы интерфейса - визуальный отклик, что дизайнеры не зря свой хлеб ели.
- Приятные глазу анимации и эффекты композиции - не больше и не меньше, чем нужно.
- Высокоуровневый и низкоуровневый интерфейсы - возможность выбора для системных разработчиков и продвинутых пользователей.

### Почему не pearOS, helloSystem, ravynOS, GnuStep..?

Poppy строится как ультимативное решение, покрывающее и системный уровень, и пользовательскую среду, ценой осознанного и взвешенного отказа от совместимости с большей частью существующего прикладного ПО (только на первых порах развития), в то время как:

- pearOS и helloSystem фокусируются преимущественно на поверхностной имитации интерфейса или заимствовании некоторых аспектов работы с macOS.
- ravynOS пытается добиться одновременно и визуальной и бинарной совместимости с Mac OS, но лишь на голом энтузиазме.
- GnuStep предлагает устаревшую реализацию Cocoa-подобных библиотек без непосредственно системной базы и пользовательского окружения.

### Почему не DE, а "ОС с оверлейным ядром"?

Poppy не является "ещё одной оболочкой" поверх существующей ОС. Цель проекта - не косметическая, а системная интеграция, невозможная в рамках окружения рабочего стола. Сам термин "DE" в общем понимании предполагает работу внутри пользовательского пространства с полным подчинением его системной модели. Любые попытки реализовать в заданных рамках собственные механизмы исполнения, межпроцессной коммуникации или декларативной безопасности - ограничены, всё это остаётся под контролем хостового ядра.

Децентрализованное гостевое ядро решает эту проблему. Оно создаёт новое пространство системных вызовов, процессов и политик, используя UNIX-подобное ядро только как базового исполнителя. При этом совместимость с существующими драйверами не ломается, что является определяющим жизнеспособность фактором для любой ОС.

### Почему не Qt / GTK, KWin / Mutter, SDDM / GDM..?

Poppy не использует существующие решения из графического стека FreeBSD / Linux, потому что это противоречит идее вдумчивого воссоздания архитектуры и системной модели OS X, где графическая подсистема, менеджер окон, композитор и окружение пользователя не существуют как набор независимых процессов, а являются частями единой среды.

Qt, KWin, SDDM и другие подобные решения исходно спроектированы для пользовательского пространства Linux и подчиняются его разрозненной IPC-модели (POSIX, Wayland, D-Bus). Это можно сравнить с портированием всего вышеперечисленного на macOS - даже при глубокой модификации такие фреймворки всё равно бы остались гостями в чужой архитектуре, а не её основой.

### Почему не Snap, FlatPak, AppImage, пакетные менеджеры..?

Poppy не признаёт **архивные** и/или **изолированные** bundle'ы как способ распространения фреймворков или приложений по той причине, что нет смысла изобретать велосипед. NextStep уже давно решил эту проблему идеальным способом, не сломав совместимость с привычным (на данный момент) UX. Степень изоляции в Snap или FlatPak часто ломает или не учитывает нативную интеграцию с ОС и возводит самодостаточность в абсолют, пакеты становятся сложными в использовании и весомыми физически. AppImage также требует системной службы для относительно нормальной интеграции, и сложнее по части модифицирования ресурсов пакета пользователем. Обязательная процедура монтирования пакетов в общем случае делает их недоступными для низкоуровневого системного программирования, а "установка" как противоположность "запуска" из любого места заставляет пользователя совершать лишние действия, тратя больше времени на решение искусственных ограничений вместо работы.

Пакетные менеджеры и репозитории считаются таким же пережитком эпохи UNIX, как и интерфейс на базе командной строки, когда общее количество файлов (библиотек и программ) в системе часто было очень маленьким и делилось между обратно-пропроционально большим количеством технически подкованных пользователей одного сервера в одном институте. Современный пользователь не хочет лезть в командную строку и разбираться с подключением репозиториев, если только он не заядлый юниксоид - такова правда жизни, которая медленно, но верно, доходит до разработчиков desktop'но-ориентированных дистрибутивов Linux, и пока ещё совсем не доходит до консерваторов. С Linux ситуация также осложняется количеством существующего ПО, которое необходимо поддерживать, чтобы не потерять и без того малую долю пользователей на рынке - однако, это не вопрос для Poppy. Здесь важна не совместимость любой ценой, а внутренне непротиворечивая экосистема. Всё, что нарушает её целостность - отсекается.