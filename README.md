**RU** | [EN](README_EN.md)

## Poppy

Свободная реализация OS X-подобного пользовательского опыта.

#### Концепт

![Концепт](Resources/Concept.png)

#### Скриншот

![Скриншот](Resources/Screenshot.png)

### Манифест

- **Poppy** &mdash; это свободный проект, развивающий сразу несколько направлений, в совокупности предоставляющих целостный пользовательский опыт, схожий с использованием Mac OS X (в частности, версии 10.9 Mavericks), но не включающий его самые худшие стороны, такие как привязка к конкретному оборудованию или плата за программное обеспечение.
- Poppy Kernel (**Opium**) &mdash; распределённое ядро уровня 1, обеспечивающее _беспрекословную_ работоспособность PSC на UNIX-подобных ядрах уровня 0. Помимо абстракций над нулевым ядром (KPL, проксирование объектов и файловых систем) оно также обладает собственной логикой (KEM, KSP и IPC). В обычной конфигурации запускается как [PID 1, UID 0] поверх FreeBSD.
	- **Ядро уровня 0** (хостовое, нулевого уровня, 0K) &mdash; ядро ОС в привычном понимании. Загружается в память с помощью оборудования и загрузчика, общается с ресурсами системы напрямую, реализует объекты (такие как процессы, потоки, таймеры, файловые системы и т.д.) и интерфейс к ним, запускает PID 1.
	- **Ядро уровня 1** (гостевое, первого уровня, 1K) &mdash; оверлейное ядро. Как и хостовое, предоставляет системные вызовы, управляет процессами, связью между ними и прочими объектами. 1K может во всём полагаться на 0K или обладать дополнительными ограничениями и расширениями. Может иметь KPL или использовать ABI ядра нулевого уровня напрямую. В теории, любое 0K подходит в качестве хоста, но на практике - лучше всего с этим справляются UNIX-подобные и микро- или экзоядра. Ядра уровня 1 делятся на два класса: централизованные - всё ядро в одном хостовом процессе, а дочерние процессы виртуализируются на базе его thread'ов; и распределённые - основной хостовый процесс ядра fork'ается, его логика сквозным образом контролирует дочерние, а всё общее состояние и связь проходят через синхронизированное и высокопроизводительное хостовое IPC типа POSIX Shared Memory. Классическим примером _централизованного_ ядра первого уровня представляется User-mode Linux, первичная цель которого состоит в _изоляции, тестировании и удобстве отладки_; в свою очередь цель _распределённого_ Opium - _независимость архитектуры при переиспользовании некоторого набора сторонних низкоуровневых решений_. Выбор _второго_ класса принципиален для жизнеспособности гостевого ядра вне "полевых испытаний", т.к. реально-используемые хостовые ядра (FreeBSD, Linux...) накладывают большие ограничения на возможности ядер первого уровня даже при UNIX-подобной архитектуре, и не годятся для централизованных 1K в desktop-сегменте.
	- Kernel Portability Layer (**KPL**) &mdash; слой совместимости, упрощающий переносимость ядра уровня 1 между хостами, засчёт предварительной минимизации различий в ABI ядер уровня 0. Развитый слой может включать I0K как способ отделиться и значительно удалиться от других ОС. Слой является надстройкой (или расширением) концепции HAL, где к "hardware" добавлено ядро нулевого уровня.
		- Integrated 0K (**I0K**) &mdash; встроенная в KPL реализация хостового ядра. Правильная архитектура гостевого ядра позволяет при желании иметь _минимальное_ хостовое экзоядро (отвечающее только за базовую среду исполнения и безопасное общение с оборудованием) и выносить всю серьёзную логику на свой собственный уровень. Хотя на практике это достаточно плохое и неоправданное решение как для разработчиков, так и для конечного пользователя, ввиду резко возрастающей сложности поддержки аппаратной части и снижения доступного для установки ОС оборудования соответственно.
	- Kernel Execution Marshall (**KEM**) &mdash; расширяемая подсистема исполнения и координации различных программных сред и форматов (Root, WebAssembly, ELF...), выполняющая инициализацию процессов, динамическое связывание библиотек, а также маршаллинг данных и вызовов функций на уровне ядра. Маршалл стремиться обеспечить такой уровень бесшовной работы множества сред, при котором конечному пользователю не придётся думать о различиях между языками программирования или форматах распространения программ. Отличается от проектов типа JVM или .NET тем, что располагаясь на более низком уровне, поддерживает многозадачность и разные модели памяти в реальном времени.
	- Kernel Security Policy (**KSP**) &mdash; декларативная подсистема безопасности, существующая как расширение POSIX-прав (UID, GID, PID), позволяющая тонко настраивать доступ к системным вызовам со стороны процессов, и явно обращающаяся к пользователю с помощью доверенных агентов (CLI и GUI) в спорных случаях. Политика позволяет настраивать доступ как на основе привычных POSIX, так и на основе новых логических ограничений. Обладает кешем решений и белым списком, может быть отключена по желанию администратора. Лучше всего работает, когда настроены пароли, но без них не становится бесполезной и все равно может ограничить даже UID 0. Ближайшие аналоги для сравнения - UAC и SELinux.
	- Inter-Process Communication (**IPC**) &mdash; в контексте Opium, совокупность подсистем взаимодействия процессов, где основной является надмножество Mach IPC, а вторичной - стандартное POSIX IPC. В отличии от XNU, POSIX IPC в Opium строится не поверх Mach IPC, а параллельно с ним.
- [Poppy Programming Language (**Root**)](OS/System/Library/Kernels/Opium/Includes/ExecutionMarshall/Root) &mdash; системный интерпретируемый язык программирования общего назначения. Официально поставляется исключительно в рамках Opium KEM, однако потенциально поддерживает сборку переносимого интерпретатора. Значительная часть PSC (в частности, нетребовательного к производительности кода) пишется на Root.
- Poppy Software Collection (**PSC**) &mdash; набор библиотек, фреймворков, консольных программ и графических приложений, совместимых с UX и некоторой частью архитектуры Darwin и OS X. Большая часть ПО в коллекции является портом и обратным инжинирингом из GNU, GnuStep, Darwin и OS X. Базовая часть PSC в большей степени зависит от уровня POSIX-совместимости ядра, чем конкретно от Opium-специфичных системных вызовов, поэтому может быть использована на некоторых ядрах уровня 0 без изменений (при совместимости сред исполнения). Та же часть, которую видит пользователь в первую очередь, а именно: `launchd`, `WindowServer`, `LoginWindow`, `Enviro`, `Dock`, `System Preferences` и т.д., могут зависеть от особых механизмов ядра и файловой структуры Poppy OS, следовательно их работа вне Opium не гарантируется и не ожидается.
- Poppy Operating System (**Poppy OS**) &mdash; сборка FreeBSD + Poppy Kernel + Poppy Programming Language + Poppy Software Collection. Всё то, к чему стремится проект Poppy, сходится в этой конечной точке. Операционную систему Poppy можно рассматривать как клон Mac OS X, если не вдаваться в подробности, и с пользовательской точки зрения это будет оправданно, однако система проходит совсем другой путь разработки: многие оригинальные решения пересматриваются, прежде чем в том или ином виде попасть в Poppy (например, система никого не ограничивает в возможностях разработки и установки тем).

## Вопросы / Ответы

### Почему не pearOS, helloSystem, ravynOS, GnuStep..?

Poppy строится как ультимативное решение, покрывающее и системный уровень, и пользовательскую среду, ценой осознанного и взвешенного отказа от совместимости с большей частью существующего прикладного ПО (только на первых порах развития), в то время как:

- pearOS и helloSystem фокусируются преимущественно на поверхностной имитации интерфейса или заимствовании некоторых аспектов работы с macOS.
- ravynOS пытается добиться одновременно и визуальной и бинарной совместимости с Mac OS, но лишь на голом энтузиазме.
- GnuStep предлагает устаревшую реализацию Cocoa-подобных библиотек без непосредственно системной базы и пользовательского окружения.

### Почему не DE, а "ОС с оверлейным ядром"?

Poppy не является "ещё одной оболочкой" поверх существующей ОС. Цель проекта - не косметическая, а системная интеграция, невозможная в рамках окружения рабочего стола. Сам термин "DE" в общем понимании предполагает работу внутри пользовательского пространства с полным подчинением его системной модели. Любые попытки реализовать в заданных рамках собственные механизмы исполнения, межпроцессной коммуникации или декларативной безопасности - ограничены, всё это остаётся под контролем хостового ядра.

Децентрализованное гостевое ядро решает эту проблему. Оно создаёт новое пространство системных вызовов, процессов и политик, используя UNIX-подобное ядро только как базового исполнителя. При этом совместимость с существующими драйверами не ломается, что является определяющим жизнеспособность фактором для любой ОС.

### Почему не Qt / GTK, KWin / Mutter, SDDM / GDM..?

Poppy не использует существующие решения из графического стека FreeBSD / Linux, потому что это противоречит идее вдумчивого воссоздания архитектуры и системной модели OS X, где графическая подсистема, менеджер окон, композитор и окружение пользователя не существуют как набор независимых процессов, а являются частями единой среды.

Qt, KWin, SDDM и другие подобные решения исходно спроектированы для пользовательского пространства Linux и подчиняются его разрозненной IPC-модели (POSIX, Wayland, D-Bus). Это можно сравнить с портированием всего вышеперечисленного на macOS - даже при глубокой модификации такие фреймворки всё равно бы остались гостями в чужой архитектуре, а не её основой.