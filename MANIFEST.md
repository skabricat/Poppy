# Манифест

## «Мультиядерность ОС»

Весь проект основан на идее, что **ядра** операционных систем можно разложить по уровням следующим образом:
- **Уровень 0** (хостовое, нулевого уровня, 0K) &mdash; ядро в привычном понимании. Загружается в память с помощью оборудования и загрузчика, общается с ресурсами системы напрямую, реализует объекты (такие как процессы, потоки, таймеры, файловые системы и т.д.) и интерфейс к ним, запускает PID 1.
- **Уровень 1** (гостевое, первого уровня, 1K) &mdash; оверлейное ядро. Как и хостовое, предоставляет системные вызовы, управляет процессами, связью между ними и прочими объектами. 1K может во всём полагаться на 0K или обладать дополнительными ограничениями и расширениями. Может иметь выделенный KPL (дальнозоркая KPL-совместимость) или использовать ABI ядра нулевого уровня напрямую (близорукая KPL-совместимость). В теории, любое 0K подходит в качестве хоста, но на практике - лучше всего с этим справляются UNIX-подобные и микро- или экзоядра.

	Ядра уровня 1 делятся на два класса: централизованные - всё ядро в одном хостовом процессе, а дочерние процессы виртуализируются на базе его thread'ов; и распределённые - основной хостовый процесс ядра fork'ается, его логика сквозным образом контролирует дочерние, а всё общее состояние и связь проходят через синхронизированное и высокопроизводительное хостовое IPC типа POSIX Shared Memory. Выбор _второго_ класса принципиален для жизнеспособности гостевого ядра вне "полевых испытаний", т.к. реально-используемые хостовые ядра (FreeBSD, Linux...) накладывают большие ограничения на возможности ядер первого уровня даже при UNIX-подобной архитектуре, и не годятся для централизованных 1K в desktop-сегменте.

	Классическим примером _централизованного_ гостевого ядра представляется User-mode Linux, первичная цель которого состоит в _удобстве изоляции, тестирования и отладки без перезагрузки физического хоста_; в свою очередь цель _распределённого_ Opium - _независимость архитектуры при переиспользовании некоторого набора сторонних низкоуровневых решений_.
	- Kernel Portability Layer (**KPL**) &mdash; слой совместимости, упрощающий переносимость ядра уровня 1 между хостами, засчёт предварительной минимизации различий в ABI ядер уровня 0. Развитый слой может включать I0K, как способ отделиться и значительно удалиться от других ОС, и предоставлять стандартную библиотеку для нативного языка К1, как способ снижения количества сборок гостевого ядра и его расширений. Слой является надстройкой (или расширением) концепции HAL, где к "hardware" добавлено ядро нулевого уровня.
		- Integrated 0K (**I0K**) &mdash; встроенная в KPL реализация хостового ядра. Правильная архитектура гостевого ядра позволяет при желании иметь _минимальное_ хостовое экзоядро (отвечающее только за базовую среду исполнения и безопасное общение с оборудованием) и выносить всю серьёзную логику на свой собственный уровень. Хотя на практике это достаточно плохое и неоправданное решение как для разработчиков, так и для конечного пользователя, ввиду резко возрастающей сложности поддержки аппаратной части и снижения доступного для установки ОС оборудования соответственно.
- **Уровень N** (супер-гостевое, N-ного уровня, NK) &mdash; оверлейное ядро, работающее (или по крайней мере экспериментально запущенное) поверх другого оверлейного ядра. Это может быть ядро, намеренно или случайно реализующее KPL-совместимость с самим собой или с неким сторонним оверлейным ядром. Термин строго контекстуален и относится только к определённой конфигурации.

## Сущности

Poppy Kernel (**Opium**) &mdash; распределённое ядро уровня 1, обеспечивающее _беспрекословную_ работоспособность PSC на UNIX-подобных ядрах уровня 0. В обычной конфигурации запускается как [PID 1, UID 0] поверх FreeBSD. Помимо абстракций над нулевым ядром (KPL), обладает собственной логикой (IOKit, VFS, KSP, IPC, KEM и объекты):
- Input/Output Kit (**IOKit**) &mdash; в контексте Opium, подсистема ввод-вывода, предоставляющая унифицированную и независимую от типа хостового ядра (более безопасную, чем сырой KPL), объектно-ориентированную модель взаимодействия с устройствами. Технически, клиентский доступ к оборудованию осуществляется по глобальному IPC гостевого ядра (для реестра и событий) и локальным системным вызовам (для конкретных устройств), но в обоих случаях используется публичный IOKit API и для клиента нет заметной разницы. Подсистема включает в себя всего три уровня семантики (информации и методов взаимодействия):
	1. На основании KPL, непосредственно в ядре: физические устройства хоста (ACPI, PCI, SATA, USB...).
	2. На основании IOKit и KPL, в shim-kext'ах: логические устройства хоста (файловые системы, точки монтирования...); виртуальные устройства хоста (RAM-диск, аудиоканал...).
	3. На основании IOKit, в полноценных kext'ах: логические устройства гостя (только на экзоядрах, которые имеют доступный для KPL аппаратный API); виртуальные устройства гостя.
- Virtual File System (**VFS**) &mdash; абстрактная подсистема, обеспечивающая единообразный доступ клиентских программ и приложений к разным типам файловых систем. В контексте Opium, VFS стандартно работает в два этапа:
	1. Регистрация файловых систем, при загрузке kext'ов. Данные, экспортируемые этими ФС, подобно семантическому набору IOKit, могут быть физическими, логическими или виртуальными. В первых двух случаях используется информация, полученная от IOKit, в третьем это необязательно. Каждый kext реализует свой конкретный набор методов для файловых систем через общий абстрактный набор. В частности, kext может быть тонким shim, проксирующим одну или несколько ФС хоста.
	2. Ответ на запросы, при исполнении процессов. Когда процесс делает системный вызов, VFS ищет в своём реестре зарегистрированную файловую систему с нужным типом (mount) или handle к ней (open, read...) и вызывает методы, реализованные kext'ом. Примером виртуальной ФС является devfs, которая получает информацию об оборудовании от IOKit и маппит вызовы к его методам устройств на обычные файловые операции POSIX.
- Kernel Security Policy (**KSP**) &mdash; декларативная подсистема безопасности, существующая как расширение POSIX-прав (UID, GID, PID), позволяющая тонко настраивать доступ к системным вызовам со стороны процессов, и явно обращающаяся к пользователю с помощью доверенных агентов (CLI и GUI) в спорных случаях. Политика позволяет настраивать доступ как на основе привычных POSIX, так и на основе новых логических ограничений. Обладает кешем решений и белым списком, может быть отключена по желанию администратора. Лучше всего работает, когда настроены пароли, но без них не становится бесполезной и все равно может ограничить даже UID 0. Ближайшие аналоги для сравнения - UAC и SELinux.
- Inter-Process Communication (**IPC**) &mdash; в контексте Opium, совокупность подсистем взаимодействия процессов, где основной является надмножество Mach IPC, а вторичной - стандартное POSIX IPC. В отличии от XNU, POSIX IPC в Opium строится не поверх Mach IPC, а параллельно с ним.
- Kernel Execution Marshall (**KEM**) &mdash; расширяемая подсистема исполнения и координации различных программных сред и форматов (Root, WebAssembly, ELF...), выполняющая инициализацию процессов, динамическое связывание библиотек, а также маршаллинг данных и вызовов функций на уровне ядра. Маршалл стремиться обеспечить такой уровень бесшовной работы множества сред, при котором конечному пользователю не придётся думать о различиях между языками программирования или форматах распространения программ. Отличается от проектов типа JVM или .NET тем, что располагаясь на более низком уровне, поддерживает многозадачность и разные модели памяти в реальном времени.

[Poppy Programming Language (**Root**)](OS/System/Library/Kernels/Opium/Includes/ExecutionMarshall/Root) &mdash; системный интерпретируемый язык программирования общего назначения. Официально поставляется исключительно в рамках Opium KEM, однако потенциально поддерживает сборку переносимого интерпретатора. Значительная часть PSC (в частности, нетребовательного к производительности кода) пишется на Root.

Poppy Software Collection (**PSC**) &mdash; набор библиотек, фреймворков, консольных программ и графических приложений, совместимых с UX и некоторой частью архитектуры Darwin и OS X. Большая часть ПО в коллекции является портом и обратным инжинирингом из GNU, GnuStep, Darwin и OS X. Базовая часть PSC в большей степени зависит от уровня POSIX-совместимости ядра, чем конкретно от Opium-специфичных системных вызовов, поэтому может быть использована на некоторых ядрах уровня 0 без изменений (при совместимости сред исполнения). Та же часть, которую видит пользователь в первую очередь, а именно: `launchd`, `WindowServer`, `LoginWindow`, `Enviro`, `Dock`, `System Preferences` и т.д., могут зависеть от особых механизмов ядра и файловой структуры Poppy OS, следовательно их работа вне Opium не гарантируется и не ожидается.

Poppy Operating System (**Poppy OS**) &mdash; сборка FreeBSD + Poppy Kernel + Poppy Programming Language + Poppy Software Collection. Всё то, к чему стремится проект Poppy, сходится в этой конечной точке. Операционную систему Poppy можно рассматривать как клон Mac OS X, если не вдаваться в подробности, и с пользовательской точки зрения это будет оправданно, однако система проходит совсем другой путь разработки: многие оригинальные решения пересматриваются, прежде чем в том или ином виде попасть в Poppy (например, система никого не ограничивает в возможностях разработки и установки тем).

## Архитектура

	Аппаратное обеспечение
	Ядро (нативной ОС) уровня 0
	Ядро (Poppy OS) уровня 1 (Opium): Общие kext'ы
		KPL: Совместимость с FreeBSD, Linux...
		IOKit: Kext'ы драйверов
		VFS: Kext'ы файловых систем
		Системные вызовы: Mach (IPC) и POSIX API, соблюдающие KSP
		KEM: Среды Root, WebAssembly, ELF
			PSC
				Библиотеки, фреймворки
					CoreFoundation Framework, CoreTypes Framework...
					CoreGraphics Framework...
					Leaf Framework
				Программы, приложения
					launchd: Launch Daemons, Launch Agents
					WindowServer, LoginWindow...
					Enviro, Dock, System Preferences, Activity Monitor...